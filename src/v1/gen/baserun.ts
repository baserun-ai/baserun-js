// @generated by protobuf-ts 2.9.1 with parameter client_grpc1
// @generated from protobuf file "baserun.proto" (package "baserun.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * @generated from protobuf message baserun.v1.Status
 */
export interface Status {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: baserun.v1.Status.StatusCode code = 2;
     */
    code: Status_StatusCode;
}
/**
 * @generated from protobuf enum baserun.v1.Status.StatusCode
 */
export enum Status_StatusCode {
    /**
     * @generated from protobuf enum value: STATUS_CODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STATUS_CODE_OK = 1;
     */
    OK = 1,
    /**
     * @generated from protobuf enum value: STATUS_CODE_ERROR = 2;
     */
    ERROR = 2
}
/**
 * @generated from protobuf message baserun.v1.ToolFunction
 */
export interface ToolFunction {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string arguments = 2;
     */
    arguments: string;
}
/**
 * @generated from protobuf message baserun.v1.ToolCall
 */
export interface ToolCall {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * @generated from protobuf field: baserun.v1.ToolFunction function = 3;
     */
    function?: ToolFunction;
}
/**
 * @generated from protobuf message baserun.v1.Message
 */
export interface Message {
    /**
     * @generated from protobuf field: string role = 1;
     */
    role: string;
    /**
     * @generated from protobuf field: string content = 2;
     */
    content: string;
    /**
     * @generated from protobuf field: string finish_reason = 3;
     */
    finishReason: string;
    /**
     * @generated from protobuf field: string function_call = 4;
     */
    functionCall: string;
    /**
     * @generated from protobuf field: repeated baserun.v1.ToolCall tool_calls = 5;
     */
    toolCalls: ToolCall[];
    /**
     * @generated from protobuf field: string tool_call_id = 6;
     */
    toolCallId: string;
    /**
     * @generated from protobuf field: string name = 7;
     */
    name: string;
    /**
     * @generated from protobuf field: string system_fingerprint = 8;
     */
    systemFingerprint: string;
}
/**
 * @generated from protobuf message baserun.v1.Run
 */
export interface Run {
    /**
     * @generated from protobuf field: string run_id = 1;
     */
    runId: string;
    /**
     * @generated from protobuf field: string suite_id = 2;
     */
    suiteId: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated string inputs = 4;
     */
    inputs: string[];
    /**
     * @generated from protobuf field: baserun.v1.Run.RunType run_type = 5;
     */
    runType: Run_RunType;
    /**
     * @generated from protobuf field: string metadata = 6;
     */
    metadata: string; // JSONified map<string, any>
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_timestamp = 7;
     */
    startTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp completion_timestamp = 8;
     */
    completionTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: string result = 9;
     */
    result: string;
    /**
     * @generated from protobuf field: string error = 10;
     */
    error: string;
    /**
     * @generated from protobuf field: string session_id = 11;
     */
    sessionId: string;
}
/**
 * @generated from protobuf enum baserun.v1.Run.RunType
 */
export enum Run_RunType {
    /**
     * @generated from protobuf enum value: RUN_TYPE_TEST = 0;
     */
    TEST = 0,
    /**
     * @generated from protobuf enum value: RUN_TYPE_PRODUCTION = 1;
     */
    PRODUCTION = 1
}
/**
 * @generated from protobuf message baserun.v1.Log
 */
export interface Log {
    /**
     * @generated from protobuf field: string run_id = 1;
     */
    runId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string payload = 3;
     */
    payload: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 4;
     */
    timestamp?: Timestamp;
}
/**
 * @generated from protobuf message baserun.v1.EndUser
 */
export interface EndUser {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string identifier = 2;
     */
    identifier: string;
}
/**
 * @generated from protobuf message baserun.v1.Model
 */
export interface Model {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string model_name = 2;
     */
    modelName: string;
    /**
     * @generated from protobuf field: string provider = 3;
     */
    provider: string;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message baserun.v1.ModelConfig
 */
export interface ModelConfig {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 model_id = 2;
     */
    modelId: number;
    /**
     * @generated from protobuf field: baserun.v1.Model model = 3;
     */
    model?: Model;
    /**
     * @generated from protobuf field: string logit_bias = 4;
     */
    logitBias: string;
    /**
     * @generated from protobuf field: float presence_penalty = 5;
     */
    presencePenalty: number;
    /**
     * @generated from protobuf field: float frequency_penalty = 6;
     */
    frequencyPenalty: number;
    /**
     * @generated from protobuf field: float temperature = 7;
     */
    temperature: number;
    /**
     * @generated from protobuf field: float top_p = 8;
     */
    topP: number;
    /**
     * @generated from protobuf field: float top_k = 9;
     */
    topK: number;
    /**
     * @generated from protobuf field: string functions = 10;
     */
    functions: string;
    /**
     * @generated from protobuf field: string function_call = 11;
     */
    functionCall: string;
}
/**
 * @generated from protobuf message baserun.v1.Span
 */
export interface Span {
    /**
     * @generated from protobuf field: string run_id = 1;
     */
    runId: string;
    /**
     * @generated from protobuf field: bytes trace_id = 2;
     */
    traceId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 span_id = 3;
     */
    spanId: bigint;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 5;
     */
    startTime?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end_time = 6;
     */
    endTime?: Timestamp;
    /**
     * @generated from protobuf field: baserun.v1.Status status = 7;
     */
    status?: Status;
    /**
     * Common Attributes
     *
     * @generated from protobuf field: string vendor = 8;
     */
    vendor: string;
    /**
     * @generated from protobuf field: string request_type = 9;
     */
    requestType: string;
    /**
     * @generated from protobuf field: string model = 10;
     */
    model: string;
    /**
     * @generated from protobuf field: int32 total_tokens = 11;
     */
    totalTokens: number;
    /**
     * @generated from protobuf field: int32 completion_tokens = 12;
     */
    completionTokens: number;
    /**
     * @generated from protobuf field: int32 prompt_tokens = 13;
     */
    promptTokens: number;
    /**
     * @generated from protobuf field: repeated baserun.v1.Message prompt_messages = 14;
     */
    promptMessages: Message[];
    /**
     * @generated from protobuf field: repeated baserun.v1.Message completions = 15;
     */
    completions: Message[];
    /**
     * OpenAI-specific attributes
     *
     * @generated from protobuf field: optional string api_base = 16;
     */
    apiBase?: string;
    /**
     * @generated from protobuf field: optional string api_type = 17;
     */
    apiType?: string;
    /**
     * @generated from protobuf field: optional string functions = 18;
     */
    functions?: string; // JSONified array<map<str, any>>
    /**
     * @generated from protobuf field: optional string function_call = 19;
     */
    functionCall?: string; // Request attribute: response function_call is in each Message
    /**
     * @generated from protobuf field: optional double temperature = 20;
     */
    temperature?: number;
    /**
     * @generated from protobuf field: optional double top_p = 21;
     */
    topP?: number;
    /**
     * @generated from protobuf field: optional int32 n = 22;
     */
    n?: number;
    /**
     * @generated from protobuf field: optional bool stream = 23;
     */
    stream?: boolean;
    /**
     * @generated from protobuf field: repeated string stop = 24;
     */
    stop: string[];
    /**
     * @generated from protobuf field: optional int32 max_tokens = 25;
     */
    maxTokens?: number;
    /**
     * @generated from protobuf field: optional double presence_penalty = 26;
     */
    presencePenalty?: number;
    /**
     * @generated from protobuf field: optional double frequency_penalty = 27;
     */
    frequencyPenalty?: number;
    /**
     * @generated from protobuf field: optional string logit_bias = 28;
     */
    logitBias?: string; // JSONified map<str, int>
    /**
     * @generated from protobuf field: optional string user = 29;
     */
    user?: string;
    /**
     * @generated from protobuf field: optional int32 logprobs = 30;
     */
    logprobs?: number;
    /**
     * @generated from protobuf field: optional bool echo = 31;
     */
    echo?: boolean;
    /**
     * @generated from protobuf field: optional string suffix = 32;
     */
    suffix?: string;
    /**
     * @generated from protobuf field: optional int32 best_of = 33;
     */
    bestOf?: number;
    /**
     * Anthropic-specific attributes
     *
     * @generated from protobuf field: optional string log_id = 34;
     */
    logId?: string;
    /**
     * @generated from protobuf field: optional double top_k = 35;
     */
    topK?: number;
    /**
     * @generated from protobuf field: baserun.v1.EndUser end_user = 36;
     */
    endUser?: EndUser;
    /**
     * @generated from protobuf field: optional string template_id = 37;
     */
    templateId?: string;
    /**
     * @generated from protobuf field: optional string template_parameters = 38;
     */
    templateParameters?: string; // JSONified map<str, any>
    /**
     * @generated from protobuf field: optional string template_string = 45;
     */
    templateString?: string;
    /**
     * @generated from protobuf field: optional string tools = 39;
     */
    tools?: string; // JSONified array<map<str, any>>
    /**
     * @generated from protobuf field: optional string tool_choice = 40;
     */
    toolChoice?: string; // JSONified map<str, any>
    /**
     * @generated from protobuf field: optional int32 seed = 41;
     */
    seed?: number;
    /**
     * @generated from protobuf field: optional string response_format = 42;
     */
    responseFormat?: string; // JSONified map<str, any>
    /**
     * @generated from protobuf field: optional string error_stacktrace = 43;
     */
    errorStacktrace?: string;
    /**
     * @generated from protobuf field: optional string completion_id = 44;
     */
    completionId?: string;
}
/**
 * @generated from protobuf message baserun.v1.Eval
 */
export interface Eval {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * @generated from protobuf field: string result = 3;
     */
    result: string;
    /**
     * @generated from protobuf field: optional double score = 5;
     */
    score?: number;
    /**
     * @generated from protobuf field: string submission = 6;
     */
    submission: string;
    /**
     * @generated from protobuf field: string payload = 7;
     */
    payload: string; // JSONified map<string, any>
}
/**
 * @generated from protobuf message baserun.v1.Check
 */
export interface Check {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string methodology = 2;
     */
    methodology: string;
    /**
     * @generated from protobuf field: string expected = 3;
     */
    expected: string; // JSONified map<string, any>
    /**
     * @generated from protobuf field: string actual = 4;
     */
    actual: string; // JSONified map<string, any>
    /**
     * @generated from protobuf field: double score = 5;
     */
    score: number;
    /**
     * @generated from protobuf field: string metadata = 6;
     */
    metadata: string; // JSONified map<string, any>
}
/**
 * @generated from protobuf message baserun.v1.Feedback
 */
export interface Feedback {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: double score = 2;
     */
    score: number;
    /**
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string; // JSONified map<string, any>
    /**
     * @generated from protobuf field: baserun.v1.EndUser end_user = 4;
     */
    endUser?: EndUser;
}
/**
 * @generated from protobuf message baserun.v1.CapturedCompletion
 */
export interface CapturedCompletion {
    /**
     * @generated from protobuf field: string completion_id = 1;
     */
    completionId: string;
    /**
     * @generated from protobuf field: repeated baserun.v1.Check checks = 2;
     */
    checks: Check[];
    /**
     * @generated from protobuf field: repeated baserun.v1.Log logs = 3;
     */
    logs: Log[];
    /**
     * @generated from protobuf field: repeated baserun.v1.Feedback feedback = 4;
     */
    feedback: Feedback[];
}
/**
 * @generated from protobuf message baserun.v1.TestSuite
 */
export interface TestSuite {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_timestamp = 3;
     */
    startTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp completion_timestamp = 4;
     */
    completionTimestamp?: Timestamp;
}
/**
 * @generated from protobuf message baserun.v1.Template
 */
export interface Template {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: baserun.v1.Template.TemplateType template_type = 3;
     */
    templateType: Template_TemplateType;
    /**
     * @generated from protobuf field: repeated baserun.v1.TemplateVersion template_versions = 4;
     */
    templateVersions: TemplateVersion[];
}
/**
 * @generated from protobuf enum baserun.v1.Template.TemplateType
 */
export enum Template_TemplateType {
    /**
     * @generated from protobuf enum value: TEMPLATE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TEMPLATE_TYPE_FORMATTED_STRING = 1;
     */
    FORMATTED_STRING = 1,
    /**
     * @generated from protobuf enum value: TEMPLATE_TYPE_JINJA2 = 2;
     */
    JINJA2 = 2
}
/**
 * @generated from protobuf message baserun.v1.TemplateVersion
 */
export interface TemplateVersion {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: baserun.v1.Template template = 2;
     */
    template?: Template;
    /**
     * @generated from protobuf field: string tag = 3;
     */
    tag: string;
    /**
     * @generated from protobuf field: string parameter_definition = 4;
     */
    parameterDefinition: string;
    /**
     * @generated from protobuf field: string template_string = 5;
     */
    templateString: string;
}
/**
 * @generated from protobuf message baserun.v1.Session
 */
export interface Session {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string identifier = 2;
     */
    identifier: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_timestamp = 3;
     */
    startTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp completion_timestamp = 4;
     */
    completionTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: baserun.v1.EndUser end_user = 5;
     */
    endUser?: EndUser;
}
/**
 * @generated from protobuf message baserun.v1.StartRunRequest
 */
export interface StartRunRequest {
    /**
     * @generated from protobuf field: baserun.v1.Run run = 1;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.StartRunResponse
 */
export interface StartRunResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.SubmitLogRequest
 */
export interface SubmitLogRequest {
    /**
     * @generated from protobuf field: baserun.v1.Log log = 1;
     */
    log?: Log;
    /**
     * @generated from protobuf field: baserun.v1.Run run = 2;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.SubmitLogResponse
 */
export interface SubmitLogResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.SubmitSpanRequest
 */
export interface SubmitSpanRequest {
    /**
     * @generated from protobuf field: baserun.v1.Span span = 1;
     */
    span?: Span;
    /**
     * @generated from protobuf field: baserun.v1.Run run = 2;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.SubmitSpanResponse
 */
export interface SubmitSpanResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.EndRunRequest
 */
export interface EndRunRequest {
    /**
     * @generated from protobuf field: baserun.v1.Run run = 1;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.EndRunResponse
 */
export interface EndRunResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.SubmitEvalRequest
 */
export interface SubmitEvalRequest {
    /**
     * @generated from protobuf field: baserun.v1.Eval eval = 1;
     */
    eval?: Eval;
    /**
     * @generated from protobuf field: baserun.v1.Run run = 2;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.SubmitEvalResponse
 */
export interface SubmitEvalResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.StartTestSuiteRequest
 */
export interface StartTestSuiteRequest {
    /**
     * @generated from protobuf field: baserun.v1.TestSuite test_suite = 1;
     */
    testSuite?: TestSuite;
}
/**
 * @generated from protobuf message baserun.v1.StartTestSuiteResponse
 */
export interface StartTestSuiteResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.EndTestSuiteRequest
 */
export interface EndTestSuiteRequest {
    /**
     * @generated from protobuf field: baserun.v1.TestSuite test_suite = 1;
     */
    testSuite?: TestSuite;
}
/**
 * @generated from protobuf message baserun.v1.EndTestSuiteResponse
 */
export interface EndTestSuiteResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message baserun.v1.StartSessionRequest
 */
export interface StartSessionRequest {
    /**
     * @generated from protobuf field: baserun.v1.Session session = 1;
     */
    session?: Session;
    /**
     * @generated from protobuf field: baserun.v1.Run run = 2;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.StartSessionResponse
 */
export interface StartSessionResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: baserun.v1.Session session = 2;
     */
    session?: Session;
}
/**
 * @generated from protobuf message baserun.v1.EndSessionRequest
 */
export interface EndSessionRequest {
    /**
     * @generated from protobuf field: baserun.v1.Session session = 1;
     */
    session?: Session;
}
/**
 * @generated from protobuf message baserun.v1.EndSessionResponse
 */
export interface EndSessionResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: baserun.v1.Session session = 2;
     */
    session?: Session;
}
/**
 * @generated from protobuf message baserun.v1.SubmitTemplateVersionRequest
 */
export interface SubmitTemplateVersionRequest {
    /**
     * @generated from protobuf field: baserun.v1.TemplateVersion template_version = 1;
     */
    templateVersion?: TemplateVersion;
}
/**
 * @generated from protobuf message baserun.v1.SubmitTemplateVersionResponse
 */
export interface SubmitTemplateVersionResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: baserun.v1.TemplateVersion template_version = 2;
     */
    templateVersion?: TemplateVersion;
}
/**
 * @generated from protobuf message baserun.v1.SubmitModelConfigRequest
 */
export interface SubmitModelConfigRequest {
    /**
     * @generated from protobuf field: baserun.v1.ModelConfig model_config = 1;
     */
    modelConfig?: ModelConfig;
}
/**
 * @generated from protobuf message baserun.v1.SubmitModelConfigResponse
 */
export interface SubmitModelConfigResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: baserun.v1.ModelConfig model_config = 2;
     */
    modelConfig?: ModelConfig;
}
/**
 * @generated from protobuf message baserun.v1.SubmitUserRequest
 */
export interface SubmitUserRequest {
    /**
     * @generated from protobuf field: baserun.v1.EndUser user = 1;
     */
    user?: EndUser;
}
/**
 * @generated from protobuf message baserun.v1.SubmitUserResponse
 */
export interface SubmitUserResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: baserun.v1.EndUser user = 2;
     */
    user?: EndUser;
}
/**
 * @generated from protobuf message baserun.v1.GetTemplatesRequest
 */
export interface GetTemplatesRequest {
}
/**
 * @generated from protobuf message baserun.v1.GetTemplatesResponse
 */
export interface GetTemplatesResponse {
    /**
     * @generated from protobuf field: repeated baserun.v1.Template templates = 1;
     */
    templates: Template[];
}
/**
 * @generated from protobuf message baserun.v1.SubmitCaptureRequest
 */
export interface SubmitCaptureRequest {
    /**
     * @generated from protobuf field: baserun.v1.CapturedCompletion capture = 1;
     */
    capture?: CapturedCompletion;
    /**
     * @generated from protobuf field: baserun.v1.Run run = 2;
     */
    run?: Run;
}
/**
 * @generated from protobuf message baserun.v1.SubmitCaptureResponse
 */
export interface SubmitCaptureResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("baserun.v1.Status", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "enum", T: () => ["baserun.v1.Status.StatusCode", Status_StatusCode, "STATUS_CODE_"] }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* baserun.v1.Status.StatusCode code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* baserun.v1.Status.StatusCode code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToolFunction$Type extends MessageType<ToolFunction> {
    constructor() {
        super("baserun.v1.ToolFunction", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "arguments", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ToolFunction>): ToolFunction {
        const message = { name: "", arguments: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ToolFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToolFunction): ToolFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string arguments */ 2:
                    message.arguments = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToolFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string arguments = 2; */
        if (message.arguments !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.arguments);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.ToolFunction
 */
export const ToolFunction = new ToolFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToolCall$Type extends MessageType<ToolCall> {
    constructor() {
        super("baserun.v1.ToolCall", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "function", kind: "message", T: () => ToolFunction }
        ]);
    }
    create(value?: PartialMessage<ToolCall>): ToolCall {
        const message = { id: "", type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ToolCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToolCall): ToolCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* baserun.v1.ToolFunction function */ 3:
                    message.function = ToolFunction.internalBinaryRead(reader, reader.uint32(), options, message.function);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToolCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* baserun.v1.ToolFunction function = 3; */
        if (message.function)
            ToolFunction.internalBinaryWrite(message.function, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.ToolCall
 */
export const ToolCall = new ToolCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("baserun.v1.Message", [
            { no: 1, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "finish_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "function_call", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "tool_calls", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ToolCall },
            { no: 6, name: "tool_call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "system_fingerprint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = { role: "", content: "", finishReason: "", functionCall: "", toolCalls: [], toolCallId: "", name: "", systemFingerprint: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string role */ 1:
                    message.role = reader.string();
                    break;
                case /* string content */ 2:
                    message.content = reader.string();
                    break;
                case /* string finish_reason */ 3:
                    message.finishReason = reader.string();
                    break;
                case /* string function_call */ 4:
                    message.functionCall = reader.string();
                    break;
                case /* repeated baserun.v1.ToolCall tool_calls */ 5:
                    message.toolCalls.push(ToolCall.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string tool_call_id */ 6:
                    message.toolCallId = reader.string();
                    break;
                case /* string name */ 7:
                    message.name = reader.string();
                    break;
                case /* string system_fingerprint */ 8:
                    message.systemFingerprint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string role = 1; */
        if (message.role !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.role);
        /* string content = 2; */
        if (message.content !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.content);
        /* string finish_reason = 3; */
        if (message.finishReason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.finishReason);
        /* string function_call = 4; */
        if (message.functionCall !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.functionCall);
        /* repeated baserun.v1.ToolCall tool_calls = 5; */
        for (let i = 0; i < message.toolCalls.length; i++)
            ToolCall.internalBinaryWrite(message.toolCalls[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string tool_call_id = 6; */
        if (message.toolCallId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.toolCallId);
        /* string name = 7; */
        if (message.name !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.name);
        /* string system_fingerprint = 8; */
        if (message.systemFingerprint !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.systemFingerprint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Run$Type extends MessageType<Run> {
    constructor() {
        super("baserun.v1.Run", [
            { no: 1, name: "run_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "suite_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "inputs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "run_type", kind: "enum", T: () => ["baserun.v1.Run.RunType", Run_RunType, "RUN_TYPE_"] },
            { no: 6, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "start_timestamp", kind: "message", T: () => Timestamp },
            { no: 8, name: "completion_timestamp", kind: "message", T: () => Timestamp },
            { no: 9, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Run>): Run {
        const message = { runId: "", suiteId: "", name: "", inputs: [], runType: 0, metadata: "", result: "", error: "", sessionId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Run>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Run): Run {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string run_id */ 1:
                    message.runId = reader.string();
                    break;
                case /* string suite_id */ 2:
                    message.suiteId = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* repeated string inputs */ 4:
                    message.inputs.push(reader.string());
                    break;
                case /* baserun.v1.Run.RunType run_type */ 5:
                    message.runType = reader.int32();
                    break;
                case /* string metadata */ 6:
                    message.metadata = reader.string();
                    break;
                case /* google.protobuf.Timestamp start_timestamp */ 7:
                    message.startTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTimestamp);
                    break;
                case /* google.protobuf.Timestamp completion_timestamp */ 8:
                    message.completionTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.completionTimestamp);
                    break;
                case /* string result */ 9:
                    message.result = reader.string();
                    break;
                case /* string error */ 10:
                    message.error = reader.string();
                    break;
                case /* string session_id */ 11:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Run, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string run_id = 1; */
        if (message.runId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.runId);
        /* string suite_id = 2; */
        if (message.suiteId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.suiteId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* repeated string inputs = 4; */
        for (let i = 0; i < message.inputs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.inputs[i]);
        /* baserun.v1.Run.RunType run_type = 5; */
        if (message.runType !== 0)
            writer.tag(5, WireType.Varint).int32(message.runType);
        /* string metadata = 6; */
        if (message.metadata !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.metadata);
        /* google.protobuf.Timestamp start_timestamp = 7; */
        if (message.startTimestamp)
            Timestamp.internalBinaryWrite(message.startTimestamp, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp completion_timestamp = 8; */
        if (message.completionTimestamp)
            Timestamp.internalBinaryWrite(message.completionTimestamp, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string result = 9; */
        if (message.result !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.result);
        /* string error = 10; */
        if (message.error !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.error);
        /* string session_id = 11; */
        if (message.sessionId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Run
 */
export const Run = new Run$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Log$Type extends MessageType<Log> {
    constructor() {
        super("baserun.v1.Log", [
            { no: 1, name: "run_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Log>): Log {
        const message = { runId: "", name: "", payload: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Log>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Log): Log {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string run_id */ 1:
                    message.runId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string payload */ 3:
                    message.payload = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 4:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Log, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string run_id = 1; */
        if (message.runId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.runId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string payload = 3; */
        if (message.payload !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payload);
        /* google.protobuf.Timestamp timestamp = 4; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Log
 */
export const Log = new Log$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndUser$Type extends MessageType<EndUser> {
    constructor() {
        super("baserun.v1.EndUser", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EndUser>): EndUser {
        const message = { id: "", identifier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndUser): EndUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string identifier */ 2:
                    message.identifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string identifier = 2; */
        if (message.identifier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.identifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndUser
 */
export const EndUser = new EndUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Model$Type extends MessageType<Model> {
    constructor() {
        super("baserun.v1.Model", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "model_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Model>): Model {
        const message = { id: 0, modelName: "", provider: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Model>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model): Model {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string model_name */ 2:
                    message.modelName = reader.string();
                    break;
                case /* string provider */ 3:
                    message.provider = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Model, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string model_name = 2; */
        if (message.modelName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modelName);
        /* string provider = 3; */
        if (message.provider !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.provider);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Model
 */
export const Model = new Model$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelConfig$Type extends MessageType<ModelConfig> {
    constructor() {
        super("baserun.v1.ModelConfig", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "model_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "model", kind: "message", T: () => Model },
            { no: 4, name: "logit_bias", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "presence_penalty", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "frequency_penalty", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "top_p", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "top_k", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "functions", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "function_call", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModelConfig>): ModelConfig {
        const message = { id: 0, modelId: 0, logitBias: "", presencePenalty: 0, frequencyPenalty: 0, temperature: 0, topP: 0, topK: 0, functions: "", functionCall: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModelConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModelConfig): ModelConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 model_id */ 2:
                    message.modelId = reader.int32();
                    break;
                case /* baserun.v1.Model model */ 3:
                    message.model = Model.internalBinaryRead(reader, reader.uint32(), options, message.model);
                    break;
                case /* string logit_bias */ 4:
                    message.logitBias = reader.string();
                    break;
                case /* float presence_penalty */ 5:
                    message.presencePenalty = reader.float();
                    break;
                case /* float frequency_penalty */ 6:
                    message.frequencyPenalty = reader.float();
                    break;
                case /* float temperature */ 7:
                    message.temperature = reader.float();
                    break;
                case /* float top_p */ 8:
                    message.topP = reader.float();
                    break;
                case /* float top_k */ 9:
                    message.topK = reader.float();
                    break;
                case /* string functions */ 10:
                    message.functions = reader.string();
                    break;
                case /* string function_call */ 11:
                    message.functionCall = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModelConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 model_id = 2; */
        if (message.modelId !== 0)
            writer.tag(2, WireType.Varint).int32(message.modelId);
        /* baserun.v1.Model model = 3; */
        if (message.model)
            Model.internalBinaryWrite(message.model, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string logit_bias = 4; */
        if (message.logitBias !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.logitBias);
        /* float presence_penalty = 5; */
        if (message.presencePenalty !== 0)
            writer.tag(5, WireType.Bit32).float(message.presencePenalty);
        /* float frequency_penalty = 6; */
        if (message.frequencyPenalty !== 0)
            writer.tag(6, WireType.Bit32).float(message.frequencyPenalty);
        /* float temperature = 7; */
        if (message.temperature !== 0)
            writer.tag(7, WireType.Bit32).float(message.temperature);
        /* float top_p = 8; */
        if (message.topP !== 0)
            writer.tag(8, WireType.Bit32).float(message.topP);
        /* float top_k = 9; */
        if (message.topK !== 0)
            writer.tag(9, WireType.Bit32).float(message.topK);
        /* string functions = 10; */
        if (message.functions !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.functions);
        /* string function_call = 11; */
        if (message.functionCall !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.functionCall);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.ModelConfig
 */
export const ModelConfig = new ModelConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Span$Type extends MessageType<Span> {
    constructor() {
        super("baserun.v1.Span", [
            { no: 1, name: "run_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trace_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "span_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "start_time", kind: "message", T: () => Timestamp },
            { no: 6, name: "end_time", kind: "message", T: () => Timestamp },
            { no: 7, name: "status", kind: "message", T: () => Status },
            { no: 8, name: "vendor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "request_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "total_tokens", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "completion_tokens", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "prompt_tokens", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "prompt_messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message },
            { no: 15, name: "completions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message },
            { no: 16, name: "api_base", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "api_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "functions", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "function_call", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "temperature", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "top_p", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 22, name: "n", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "stream", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "stop", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "max_tokens", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "presence_penalty", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 27, name: "frequency_penalty", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 28, name: "logit_bias", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "user", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "logprobs", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "echo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "suffix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "best_of", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "log_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "top_k", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 36, name: "end_user", kind: "message", T: () => EndUser },
            { no: 37, name: "template_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "template_parameters", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 45, name: "template_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 39, name: "tools", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "tool_choice", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "seed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 42, name: "response_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 43, name: "error_stacktrace", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 44, name: "completion_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Span>): Span {
        const message = { runId: "", traceId: new Uint8Array(0), spanId: 0n, name: "", vendor: "", requestType: "", model: "", totalTokens: 0, completionTokens: 0, promptTokens: 0, promptMessages: [], completions: [], stop: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Span>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Span): Span {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string run_id */ 1:
                    message.runId = reader.string();
                    break;
                case /* bytes trace_id */ 2:
                    message.traceId = reader.bytes();
                    break;
                case /* uint64 span_id */ 3:
                    message.spanId = reader.uint64().toBigInt();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp start_time */ 5:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp end_time */ 6:
                    message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                case /* baserun.v1.Status status */ 7:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string vendor */ 8:
                    message.vendor = reader.string();
                    break;
                case /* string request_type */ 9:
                    message.requestType = reader.string();
                    break;
                case /* string model */ 10:
                    message.model = reader.string();
                    break;
                case /* int32 total_tokens */ 11:
                    message.totalTokens = reader.int32();
                    break;
                case /* int32 completion_tokens */ 12:
                    message.completionTokens = reader.int32();
                    break;
                case /* int32 prompt_tokens */ 13:
                    message.promptTokens = reader.int32();
                    break;
                case /* repeated baserun.v1.Message prompt_messages */ 14:
                    message.promptMessages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated baserun.v1.Message completions */ 15:
                    message.completions.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string api_base */ 16:
                    message.apiBase = reader.string();
                    break;
                case /* optional string api_type */ 17:
                    message.apiType = reader.string();
                    break;
                case /* optional string functions */ 18:
                    message.functions = reader.string();
                    break;
                case /* optional string function_call */ 19:
                    message.functionCall = reader.string();
                    break;
                case /* optional double temperature */ 20:
                    message.temperature = reader.double();
                    break;
                case /* optional double top_p */ 21:
                    message.topP = reader.double();
                    break;
                case /* optional int32 n */ 22:
                    message.n = reader.int32();
                    break;
                case /* optional bool stream */ 23:
                    message.stream = reader.bool();
                    break;
                case /* repeated string stop */ 24:
                    message.stop.push(reader.string());
                    break;
                case /* optional int32 max_tokens */ 25:
                    message.maxTokens = reader.int32();
                    break;
                case /* optional double presence_penalty */ 26:
                    message.presencePenalty = reader.double();
                    break;
                case /* optional double frequency_penalty */ 27:
                    message.frequencyPenalty = reader.double();
                    break;
                case /* optional string logit_bias */ 28:
                    message.logitBias = reader.string();
                    break;
                case /* optional string user */ 29:
                    message.user = reader.string();
                    break;
                case /* optional int32 logprobs */ 30:
                    message.logprobs = reader.int32();
                    break;
                case /* optional bool echo */ 31:
                    message.echo = reader.bool();
                    break;
                case /* optional string suffix */ 32:
                    message.suffix = reader.string();
                    break;
                case /* optional int32 best_of */ 33:
                    message.bestOf = reader.int32();
                    break;
                case /* optional string log_id */ 34:
                    message.logId = reader.string();
                    break;
                case /* optional double top_k */ 35:
                    message.topK = reader.double();
                    break;
                case /* baserun.v1.EndUser end_user */ 36:
                    message.endUser = EndUser.internalBinaryRead(reader, reader.uint32(), options, message.endUser);
                    break;
                case /* optional string template_id */ 37:
                    message.templateId = reader.string();
                    break;
                case /* optional string template_parameters */ 38:
                    message.templateParameters = reader.string();
                    break;
                case /* optional string template_string */ 45:
                    message.templateString = reader.string();
                    break;
                case /* optional string tools */ 39:
                    message.tools = reader.string();
                    break;
                case /* optional string tool_choice */ 40:
                    message.toolChoice = reader.string();
                    break;
                case /* optional int32 seed */ 41:
                    message.seed = reader.int32();
                    break;
                case /* optional string response_format */ 42:
                    message.responseFormat = reader.string();
                    break;
                case /* optional string error_stacktrace */ 43:
                    message.errorStacktrace = reader.string();
                    break;
                case /* optional string completion_id */ 44:
                    message.completionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Span, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string run_id = 1; */
        if (message.runId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.runId);
        /* bytes trace_id = 2; */
        if (message.traceId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.traceId);
        /* uint64 span_id = 3; */
        if (message.spanId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.spanId);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp start_time = 5; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end_time = 6; */
        if (message.endTime)
            Timestamp.internalBinaryWrite(message.endTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.Status status = 7; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string vendor = 8; */
        if (message.vendor !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.vendor);
        /* string request_type = 9; */
        if (message.requestType !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.requestType);
        /* string model = 10; */
        if (message.model !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.model);
        /* int32 total_tokens = 11; */
        if (message.totalTokens !== 0)
            writer.tag(11, WireType.Varint).int32(message.totalTokens);
        /* int32 completion_tokens = 12; */
        if (message.completionTokens !== 0)
            writer.tag(12, WireType.Varint).int32(message.completionTokens);
        /* int32 prompt_tokens = 13; */
        if (message.promptTokens !== 0)
            writer.tag(13, WireType.Varint).int32(message.promptTokens);
        /* repeated baserun.v1.Message prompt_messages = 14; */
        for (let i = 0; i < message.promptMessages.length; i++)
            Message.internalBinaryWrite(message.promptMessages[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated baserun.v1.Message completions = 15; */
        for (let i = 0; i < message.completions.length; i++)
            Message.internalBinaryWrite(message.completions[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional string api_base = 16; */
        if (message.apiBase !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.apiBase);
        /* optional string api_type = 17; */
        if (message.apiType !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.apiType);
        /* optional string functions = 18; */
        if (message.functions !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.functions);
        /* optional string function_call = 19; */
        if (message.functionCall !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.functionCall);
        /* optional double temperature = 20; */
        if (message.temperature !== undefined)
            writer.tag(20, WireType.Bit64).double(message.temperature);
        /* optional double top_p = 21; */
        if (message.topP !== undefined)
            writer.tag(21, WireType.Bit64).double(message.topP);
        /* optional int32 n = 22; */
        if (message.n !== undefined)
            writer.tag(22, WireType.Varint).int32(message.n);
        /* optional bool stream = 23; */
        if (message.stream !== undefined)
            writer.tag(23, WireType.Varint).bool(message.stream);
        /* repeated string stop = 24; */
        for (let i = 0; i < message.stop.length; i++)
            writer.tag(24, WireType.LengthDelimited).string(message.stop[i]);
        /* optional int32 max_tokens = 25; */
        if (message.maxTokens !== undefined)
            writer.tag(25, WireType.Varint).int32(message.maxTokens);
        /* optional double presence_penalty = 26; */
        if (message.presencePenalty !== undefined)
            writer.tag(26, WireType.Bit64).double(message.presencePenalty);
        /* optional double frequency_penalty = 27; */
        if (message.frequencyPenalty !== undefined)
            writer.tag(27, WireType.Bit64).double(message.frequencyPenalty);
        /* optional string logit_bias = 28; */
        if (message.logitBias !== undefined)
            writer.tag(28, WireType.LengthDelimited).string(message.logitBias);
        /* optional string user = 29; */
        if (message.user !== undefined)
            writer.tag(29, WireType.LengthDelimited).string(message.user);
        /* optional int32 logprobs = 30; */
        if (message.logprobs !== undefined)
            writer.tag(30, WireType.Varint).int32(message.logprobs);
        /* optional bool echo = 31; */
        if (message.echo !== undefined)
            writer.tag(31, WireType.Varint).bool(message.echo);
        /* optional string suffix = 32; */
        if (message.suffix !== undefined)
            writer.tag(32, WireType.LengthDelimited).string(message.suffix);
        /* optional int32 best_of = 33; */
        if (message.bestOf !== undefined)
            writer.tag(33, WireType.Varint).int32(message.bestOf);
        /* optional string log_id = 34; */
        if (message.logId !== undefined)
            writer.tag(34, WireType.LengthDelimited).string(message.logId);
        /* optional double top_k = 35; */
        if (message.topK !== undefined)
            writer.tag(35, WireType.Bit64).double(message.topK);
        /* baserun.v1.EndUser end_user = 36; */
        if (message.endUser)
            EndUser.internalBinaryWrite(message.endUser, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* optional string template_id = 37; */
        if (message.templateId !== undefined)
            writer.tag(37, WireType.LengthDelimited).string(message.templateId);
        /* optional string template_parameters = 38; */
        if (message.templateParameters !== undefined)
            writer.tag(38, WireType.LengthDelimited).string(message.templateParameters);
        /* optional string template_string = 45; */
        if (message.templateString !== undefined)
            writer.tag(45, WireType.LengthDelimited).string(message.templateString);
        /* optional string tools = 39; */
        if (message.tools !== undefined)
            writer.tag(39, WireType.LengthDelimited).string(message.tools);
        /* optional string tool_choice = 40; */
        if (message.toolChoice !== undefined)
            writer.tag(40, WireType.LengthDelimited).string(message.toolChoice);
        /* optional int32 seed = 41; */
        if (message.seed !== undefined)
            writer.tag(41, WireType.Varint).int32(message.seed);
        /* optional string response_format = 42; */
        if (message.responseFormat !== undefined)
            writer.tag(42, WireType.LengthDelimited).string(message.responseFormat);
        /* optional string error_stacktrace = 43; */
        if (message.errorStacktrace !== undefined)
            writer.tag(43, WireType.LengthDelimited).string(message.errorStacktrace);
        /* optional string completion_id = 44; */
        if (message.completionId !== undefined)
            writer.tag(44, WireType.LengthDelimited).string(message.completionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Span
 */
export const Span = new Span$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Eval$Type extends MessageType<Eval> {
    constructor() {
        super("baserun.v1.Eval", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "score", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "submission", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Eval>): Eval {
        const message = { name: "", type: "", result: "", submission: "", payload: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Eval>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Eval): Eval {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string result */ 3:
                    message.result = reader.string();
                    break;
                case /* optional double score */ 5:
                    message.score = reader.double();
                    break;
                case /* string submission */ 6:
                    message.submission = reader.string();
                    break;
                case /* string payload */ 7:
                    message.payload = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Eval, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string result = 3; */
        if (message.result !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.result);
        /* optional double score = 5; */
        if (message.score !== undefined)
            writer.tag(5, WireType.Bit64).double(message.score);
        /* string submission = 6; */
        if (message.submission !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.submission);
        /* string payload = 7; */
        if (message.payload !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Eval
 */
export const Eval = new Eval$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Check$Type extends MessageType<Check> {
    constructor() {
        super("baserun.v1.Check", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "methodology", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expected", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "actual", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "score", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Check>): Check {
        const message = { name: "", methodology: "", expected: "", actual: "", score: 0, metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Check>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Check): Check {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string methodology */ 2:
                    message.methodology = reader.string();
                    break;
                case /* string expected */ 3:
                    message.expected = reader.string();
                    break;
                case /* string actual */ 4:
                    message.actual = reader.string();
                    break;
                case /* double score */ 5:
                    message.score = reader.double();
                    break;
                case /* string metadata */ 6:
                    message.metadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Check, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string methodology = 2; */
        if (message.methodology !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.methodology);
        /* string expected = 3; */
        if (message.expected !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.expected);
        /* string actual = 4; */
        if (message.actual !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.actual);
        /* double score = 5; */
        if (message.score !== 0)
            writer.tag(5, WireType.Bit64).double(message.score);
        /* string metadata = 6; */
        if (message.metadata !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Check
 */
export const Check = new Check$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Feedback$Type extends MessageType<Feedback> {
    constructor() {
        super("baserun.v1.Feedback", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "score", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "end_user", kind: "message", T: () => EndUser }
        ]);
    }
    create(value?: PartialMessage<Feedback>): Feedback {
        const message = { name: "", score: 0, metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Feedback>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Feedback): Feedback {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* double score */ 2:
                    message.score = reader.double();
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                case /* baserun.v1.EndUser end_user */ 4:
                    message.endUser = EndUser.internalBinaryRead(reader, reader.uint32(), options, message.endUser);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Feedback, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* double score = 2; */
        if (message.score !== 0)
            writer.tag(2, WireType.Bit64).double(message.score);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        /* baserun.v1.EndUser end_user = 4; */
        if (message.endUser)
            EndUser.internalBinaryWrite(message.endUser, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Feedback
 */
export const Feedback = new Feedback$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CapturedCompletion$Type extends MessageType<CapturedCompletion> {
    constructor() {
        super("baserun.v1.CapturedCompletion", [
            { no: 1, name: "completion_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Check },
            { no: 3, name: "logs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Log },
            { no: 4, name: "feedback", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Feedback }
        ]);
    }
    create(value?: PartialMessage<CapturedCompletion>): CapturedCompletion {
        const message = { completionId: "", checks: [], logs: [], feedback: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CapturedCompletion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CapturedCompletion): CapturedCompletion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string completion_id */ 1:
                    message.completionId = reader.string();
                    break;
                case /* repeated baserun.v1.Check checks */ 2:
                    message.checks.push(Check.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated baserun.v1.Log logs */ 3:
                    message.logs.push(Log.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated baserun.v1.Feedback feedback */ 4:
                    message.feedback.push(Feedback.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CapturedCompletion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string completion_id = 1; */
        if (message.completionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.completionId);
        /* repeated baserun.v1.Check checks = 2; */
        for (let i = 0; i < message.checks.length; i++)
            Check.internalBinaryWrite(message.checks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated baserun.v1.Log logs = 3; */
        for (let i = 0; i < message.logs.length; i++)
            Log.internalBinaryWrite(message.logs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated baserun.v1.Feedback feedback = 4; */
        for (let i = 0; i < message.feedback.length; i++)
            Feedback.internalBinaryWrite(message.feedback[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.CapturedCompletion
 */
export const CapturedCompletion = new CapturedCompletion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestSuite$Type extends MessageType<TestSuite> {
    constructor() {
        super("baserun.v1.TestSuite", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_timestamp", kind: "message", T: () => Timestamp },
            { no: 4, name: "completion_timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TestSuite>): TestSuite {
        const message = { id: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestSuite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestSuite): TestSuite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp start_timestamp */ 3:
                    message.startTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTimestamp);
                    break;
                case /* google.protobuf.Timestamp completion_timestamp */ 4:
                    message.completionTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.completionTimestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestSuite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp start_timestamp = 3; */
        if (message.startTimestamp)
            Timestamp.internalBinaryWrite(message.startTimestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp completion_timestamp = 4; */
        if (message.completionTimestamp)
            Timestamp.internalBinaryWrite(message.completionTimestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.TestSuite
 */
export const TestSuite = new TestSuite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Template$Type extends MessageType<Template> {
    constructor() {
        super("baserun.v1.Template", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "template_type", kind: "enum", T: () => ["baserun.v1.Template.TemplateType", Template_TemplateType, "TEMPLATE_TYPE_"] },
            { no: 4, name: "template_versions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TemplateVersion }
        ]);
    }
    create(value?: PartialMessage<Template>): Template {
        const message = { id: "", name: "", templateType: 0, templateVersions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Template>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Template): Template {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* baserun.v1.Template.TemplateType template_type */ 3:
                    message.templateType = reader.int32();
                    break;
                case /* repeated baserun.v1.TemplateVersion template_versions */ 4:
                    message.templateVersions.push(TemplateVersion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Template, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* baserun.v1.Template.TemplateType template_type = 3; */
        if (message.templateType !== 0)
            writer.tag(3, WireType.Varint).int32(message.templateType);
        /* repeated baserun.v1.TemplateVersion template_versions = 4; */
        for (let i = 0; i < message.templateVersions.length; i++)
            TemplateVersion.internalBinaryWrite(message.templateVersions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Template
 */
export const Template = new Template$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemplateVersion$Type extends MessageType<TemplateVersion> {
    constructor() {
        super("baserun.v1.TemplateVersion", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "template", kind: "message", T: () => Template },
            { no: 3, name: "tag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parameter_definition", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "template_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TemplateVersion>): TemplateVersion {
        const message = { id: "", tag: "", parameterDefinition: "", templateString: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TemplateVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemplateVersion): TemplateVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* baserun.v1.Template template */ 2:
                    message.template = Template.internalBinaryRead(reader, reader.uint32(), options, message.template);
                    break;
                case /* string tag */ 3:
                    message.tag = reader.string();
                    break;
                case /* string parameter_definition */ 4:
                    message.parameterDefinition = reader.string();
                    break;
                case /* string template_string */ 5:
                    message.templateString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemplateVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* baserun.v1.Template template = 2; */
        if (message.template)
            Template.internalBinaryWrite(message.template, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string tag = 3; */
        if (message.tag !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tag);
        /* string parameter_definition = 4; */
        if (message.parameterDefinition !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.parameterDefinition);
        /* string template_string = 5; */
        if (message.templateString !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.templateString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.TemplateVersion
 */
export const TemplateVersion = new TemplateVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Session$Type extends MessageType<Session> {
    constructor() {
        super("baserun.v1.Session", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_timestamp", kind: "message", T: () => Timestamp },
            { no: 4, name: "completion_timestamp", kind: "message", T: () => Timestamp },
            { no: 5, name: "end_user", kind: "message", T: () => EndUser }
        ]);
    }
    create(value?: PartialMessage<Session>): Session {
        const message = { id: "", identifier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Session>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Session): Session {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string identifier */ 2:
                    message.identifier = reader.string();
                    break;
                case /* google.protobuf.Timestamp start_timestamp */ 3:
                    message.startTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTimestamp);
                    break;
                case /* google.protobuf.Timestamp completion_timestamp */ 4:
                    message.completionTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.completionTimestamp);
                    break;
                case /* baserun.v1.EndUser end_user */ 5:
                    message.endUser = EndUser.internalBinaryRead(reader, reader.uint32(), options, message.endUser);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Session, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string identifier = 2; */
        if (message.identifier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.identifier);
        /* google.protobuf.Timestamp start_timestamp = 3; */
        if (message.startTimestamp)
            Timestamp.internalBinaryWrite(message.startTimestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp completion_timestamp = 4; */
        if (message.completionTimestamp)
            Timestamp.internalBinaryWrite(message.completionTimestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.EndUser end_user = 5; */
        if (message.endUser)
            EndUser.internalBinaryWrite(message.endUser, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.Session
 */
export const Session = new Session$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartRunRequest$Type extends MessageType<StartRunRequest> {
    constructor() {
        super("baserun.v1.StartRunRequest", [
            { no: 1, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<StartRunRequest>): StartRunRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartRunRequest): StartRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Run run */ 1:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Run run = 1; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.StartRunRequest
 */
export const StartRunRequest = new StartRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartRunResponse$Type extends MessageType<StartRunResponse> {
    constructor() {
        super("baserun.v1.StartRunResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartRunResponse>): StartRunResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartRunResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartRunResponse): StartRunResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartRunResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.StartRunResponse
 */
export const StartRunResponse = new StartRunResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitLogRequest$Type extends MessageType<SubmitLogRequest> {
    constructor() {
        super("baserun.v1.SubmitLogRequest", [
            { no: 1, name: "log", kind: "message", T: () => Log },
            { no: 2, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<SubmitLogRequest>): SubmitLogRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitLogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitLogRequest): SubmitLogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Log log */ 1:
                    message.log = Log.internalBinaryRead(reader, reader.uint32(), options, message.log);
                    break;
                case /* baserun.v1.Run run */ 2:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitLogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Log log = 1; */
        if (message.log)
            Log.internalBinaryWrite(message.log, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.Run run = 2; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitLogRequest
 */
export const SubmitLogRequest = new SubmitLogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitLogResponse$Type extends MessageType<SubmitLogResponse> {
    constructor() {
        super("baserun.v1.SubmitLogResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitLogResponse>): SubmitLogResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitLogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitLogResponse): SubmitLogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitLogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitLogResponse
 */
export const SubmitLogResponse = new SubmitLogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitSpanRequest$Type extends MessageType<SubmitSpanRequest> {
    constructor() {
        super("baserun.v1.SubmitSpanRequest", [
            { no: 1, name: "span", kind: "message", T: () => Span },
            { no: 2, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<SubmitSpanRequest>): SubmitSpanRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitSpanRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitSpanRequest): SubmitSpanRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Span span */ 1:
                    message.span = Span.internalBinaryRead(reader, reader.uint32(), options, message.span);
                    break;
                case /* baserun.v1.Run run */ 2:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitSpanRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Span span = 1; */
        if (message.span)
            Span.internalBinaryWrite(message.span, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.Run run = 2; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitSpanRequest
 */
export const SubmitSpanRequest = new SubmitSpanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitSpanResponse$Type extends MessageType<SubmitSpanResponse> {
    constructor() {
        super("baserun.v1.SubmitSpanResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitSpanResponse>): SubmitSpanResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitSpanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitSpanResponse): SubmitSpanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitSpanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitSpanResponse
 */
export const SubmitSpanResponse = new SubmitSpanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndRunRequest$Type extends MessageType<EndRunRequest> {
    constructor() {
        super("baserun.v1.EndRunRequest", [
            { no: 1, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<EndRunRequest>): EndRunRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndRunRequest): EndRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Run run */ 1:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Run run = 1; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndRunRequest
 */
export const EndRunRequest = new EndRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndRunResponse$Type extends MessageType<EndRunResponse> {
    constructor() {
        super("baserun.v1.EndRunResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EndRunResponse>): EndRunResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndRunResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndRunResponse): EndRunResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndRunResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndRunResponse
 */
export const EndRunResponse = new EndRunResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvalRequest$Type extends MessageType<SubmitEvalRequest> {
    constructor() {
        super("baserun.v1.SubmitEvalRequest", [
            { no: 1, name: "eval", kind: "message", T: () => Eval },
            { no: 2, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<SubmitEvalRequest>): SubmitEvalRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvalRequest): SubmitEvalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Eval eval */ 1:
                    message.eval = Eval.internalBinaryRead(reader, reader.uint32(), options, message.eval);
                    break;
                case /* baserun.v1.Run run */ 2:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Eval eval = 1; */
        if (message.eval)
            Eval.internalBinaryWrite(message.eval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.Run run = 2; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitEvalRequest
 */
export const SubmitEvalRequest = new SubmitEvalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvalResponse$Type extends MessageType<SubmitEvalResponse> {
    constructor() {
        super("baserun.v1.SubmitEvalResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvalResponse>): SubmitEvalResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvalResponse): SubmitEvalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitEvalResponse
 */
export const SubmitEvalResponse = new SubmitEvalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTestSuiteRequest$Type extends MessageType<StartTestSuiteRequest> {
    constructor() {
        super("baserun.v1.StartTestSuiteRequest", [
            { no: 1, name: "test_suite", kind: "message", T: () => TestSuite }
        ]);
    }
    create(value?: PartialMessage<StartTestSuiteRequest>): StartTestSuiteRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartTestSuiteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTestSuiteRequest): StartTestSuiteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.TestSuite test_suite */ 1:
                    message.testSuite = TestSuite.internalBinaryRead(reader, reader.uint32(), options, message.testSuite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTestSuiteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.TestSuite test_suite = 1; */
        if (message.testSuite)
            TestSuite.internalBinaryWrite(message.testSuite, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.StartTestSuiteRequest
 */
export const StartTestSuiteRequest = new StartTestSuiteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTestSuiteResponse$Type extends MessageType<StartTestSuiteResponse> {
    constructor() {
        super("baserun.v1.StartTestSuiteResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartTestSuiteResponse>): StartTestSuiteResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartTestSuiteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTestSuiteResponse): StartTestSuiteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTestSuiteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.StartTestSuiteResponse
 */
export const StartTestSuiteResponse = new StartTestSuiteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndTestSuiteRequest$Type extends MessageType<EndTestSuiteRequest> {
    constructor() {
        super("baserun.v1.EndTestSuiteRequest", [
            { no: 1, name: "test_suite", kind: "message", T: () => TestSuite }
        ]);
    }
    create(value?: PartialMessage<EndTestSuiteRequest>): EndTestSuiteRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndTestSuiteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndTestSuiteRequest): EndTestSuiteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.TestSuite test_suite */ 1:
                    message.testSuite = TestSuite.internalBinaryRead(reader, reader.uint32(), options, message.testSuite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndTestSuiteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.TestSuite test_suite = 1; */
        if (message.testSuite)
            TestSuite.internalBinaryWrite(message.testSuite, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndTestSuiteRequest
 */
export const EndTestSuiteRequest = new EndTestSuiteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndTestSuiteResponse$Type extends MessageType<EndTestSuiteResponse> {
    constructor() {
        super("baserun.v1.EndTestSuiteResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EndTestSuiteResponse>): EndTestSuiteResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndTestSuiteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndTestSuiteResponse): EndTestSuiteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndTestSuiteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndTestSuiteResponse
 */
export const EndTestSuiteResponse = new EndTestSuiteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionRequest$Type extends MessageType<StartSessionRequest> {
    constructor() {
        super("baserun.v1.StartSessionRequest", [
            { no: 1, name: "session", kind: "message", T: () => Session },
            { no: 2, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<StartSessionRequest>): StartSessionRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartSessionRequest): StartSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Session session */ 1:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* baserun.v1.Run run */ 2:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Session session = 1; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.Run run = 2; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.StartSessionRequest
 */
export const StartSessionRequest = new StartSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionResponse$Type extends MessageType<StartSessionResponse> {
    constructor() {
        super("baserun.v1.StartSessionResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "session", kind: "message", T: () => Session }
        ]);
    }
    create(value?: PartialMessage<StartSessionResponse>): StartSessionResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartSessionResponse): StartSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* baserun.v1.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* baserun.v1.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.StartSessionResponse
 */
export const StartSessionResponse = new StartSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndSessionRequest$Type extends MessageType<EndSessionRequest> {
    constructor() {
        super("baserun.v1.EndSessionRequest", [
            { no: 1, name: "session", kind: "message", T: () => Session }
        ]);
    }
    create(value?: PartialMessage<EndSessionRequest>): EndSessionRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndSessionRequest): EndSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.Session session */ 1:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.Session session = 1; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndSessionRequest
 */
export const EndSessionRequest = new EndSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndSessionResponse$Type extends MessageType<EndSessionResponse> {
    constructor() {
        super("baserun.v1.EndSessionResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "session", kind: "message", T: () => Session }
        ]);
    }
    create(value?: PartialMessage<EndSessionResponse>): EndSessionResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndSessionResponse): EndSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* baserun.v1.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* baserun.v1.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.EndSessionResponse
 */
export const EndSessionResponse = new EndSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitTemplateVersionRequest$Type extends MessageType<SubmitTemplateVersionRequest> {
    constructor() {
        super("baserun.v1.SubmitTemplateVersionRequest", [
            { no: 1, name: "template_version", kind: "message", T: () => TemplateVersion }
        ]);
    }
    create(value?: PartialMessage<SubmitTemplateVersionRequest>): SubmitTemplateVersionRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitTemplateVersionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitTemplateVersionRequest): SubmitTemplateVersionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.TemplateVersion template_version */ 1:
                    message.templateVersion = TemplateVersion.internalBinaryRead(reader, reader.uint32(), options, message.templateVersion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitTemplateVersionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.TemplateVersion template_version = 1; */
        if (message.templateVersion)
            TemplateVersion.internalBinaryWrite(message.templateVersion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitTemplateVersionRequest
 */
export const SubmitTemplateVersionRequest = new SubmitTemplateVersionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitTemplateVersionResponse$Type extends MessageType<SubmitTemplateVersionResponse> {
    constructor() {
        super("baserun.v1.SubmitTemplateVersionResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "template_version", kind: "message", T: () => TemplateVersion }
        ]);
    }
    create(value?: PartialMessage<SubmitTemplateVersionResponse>): SubmitTemplateVersionResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitTemplateVersionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitTemplateVersionResponse): SubmitTemplateVersionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* baserun.v1.TemplateVersion template_version */ 2:
                    message.templateVersion = TemplateVersion.internalBinaryRead(reader, reader.uint32(), options, message.templateVersion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitTemplateVersionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* baserun.v1.TemplateVersion template_version = 2; */
        if (message.templateVersion)
            TemplateVersion.internalBinaryWrite(message.templateVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitTemplateVersionResponse
 */
export const SubmitTemplateVersionResponse = new SubmitTemplateVersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitModelConfigRequest$Type extends MessageType<SubmitModelConfigRequest> {
    constructor() {
        super("baserun.v1.SubmitModelConfigRequest", [
            { no: 1, name: "model_config", kind: "message", T: () => ModelConfig }
        ]);
    }
    create(value?: PartialMessage<SubmitModelConfigRequest>): SubmitModelConfigRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitModelConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitModelConfigRequest): SubmitModelConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.ModelConfig model_config */ 1:
                    message.modelConfig = ModelConfig.internalBinaryRead(reader, reader.uint32(), options, message.modelConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitModelConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.ModelConfig model_config = 1; */
        if (message.modelConfig)
            ModelConfig.internalBinaryWrite(message.modelConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitModelConfigRequest
 */
export const SubmitModelConfigRequest = new SubmitModelConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitModelConfigResponse$Type extends MessageType<SubmitModelConfigResponse> {
    constructor() {
        super("baserun.v1.SubmitModelConfigResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "model_config", kind: "message", T: () => ModelConfig }
        ]);
    }
    create(value?: PartialMessage<SubmitModelConfigResponse>): SubmitModelConfigResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitModelConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitModelConfigResponse): SubmitModelConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* baserun.v1.ModelConfig model_config */ 2:
                    message.modelConfig = ModelConfig.internalBinaryRead(reader, reader.uint32(), options, message.modelConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitModelConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* baserun.v1.ModelConfig model_config = 2; */
        if (message.modelConfig)
            ModelConfig.internalBinaryWrite(message.modelConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitModelConfigResponse
 */
export const SubmitModelConfigResponse = new SubmitModelConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitUserRequest$Type extends MessageType<SubmitUserRequest> {
    constructor() {
        super("baserun.v1.SubmitUserRequest", [
            { no: 1, name: "user", kind: "message", T: () => EndUser }
        ]);
    }
    create(value?: PartialMessage<SubmitUserRequest>): SubmitUserRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitUserRequest): SubmitUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.EndUser user */ 1:
                    message.user = EndUser.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.EndUser user = 1; */
        if (message.user)
            EndUser.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitUserRequest
 */
export const SubmitUserRequest = new SubmitUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitUserResponse$Type extends MessageType<SubmitUserResponse> {
    constructor() {
        super("baserun.v1.SubmitUserResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user", kind: "message", T: () => EndUser }
        ]);
    }
    create(value?: PartialMessage<SubmitUserResponse>): SubmitUserResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitUserResponse): SubmitUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* baserun.v1.EndUser user */ 2:
                    message.user = EndUser.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* baserun.v1.EndUser user = 2; */
        if (message.user)
            EndUser.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitUserResponse
 */
export const SubmitUserResponse = new SubmitUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTemplatesRequest$Type extends MessageType<GetTemplatesRequest> {
    constructor() {
        super("baserun.v1.GetTemplatesRequest", []);
    }
    create(value?: PartialMessage<GetTemplatesRequest>): GetTemplatesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTemplatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTemplatesRequest): GetTemplatesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetTemplatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.GetTemplatesRequest
 */
export const GetTemplatesRequest = new GetTemplatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTemplatesResponse$Type extends MessageType<GetTemplatesResponse> {
    constructor() {
        super("baserun.v1.GetTemplatesResponse", [
            { no: 1, name: "templates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Template }
        ]);
    }
    create(value?: PartialMessage<GetTemplatesResponse>): GetTemplatesResponse {
        const message = { templates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTemplatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTemplatesResponse): GetTemplatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated baserun.v1.Template templates */ 1:
                    message.templates.push(Template.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTemplatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated baserun.v1.Template templates = 1; */
        for (let i = 0; i < message.templates.length; i++)
            Template.internalBinaryWrite(message.templates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.GetTemplatesResponse
 */
export const GetTemplatesResponse = new GetTemplatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitCaptureRequest$Type extends MessageType<SubmitCaptureRequest> {
    constructor() {
        super("baserun.v1.SubmitCaptureRequest", [
            { no: 1, name: "capture", kind: "message", T: () => CapturedCompletion },
            { no: 2, name: "run", kind: "message", T: () => Run }
        ]);
    }
    create(value?: PartialMessage<SubmitCaptureRequest>): SubmitCaptureRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitCaptureRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitCaptureRequest): SubmitCaptureRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* baserun.v1.CapturedCompletion capture */ 1:
                    message.capture = CapturedCompletion.internalBinaryRead(reader, reader.uint32(), options, message.capture);
                    break;
                case /* baserun.v1.Run run */ 2:
                    message.run = Run.internalBinaryRead(reader, reader.uint32(), options, message.run);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitCaptureRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* baserun.v1.CapturedCompletion capture = 1; */
        if (message.capture)
            CapturedCompletion.internalBinaryWrite(message.capture, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* baserun.v1.Run run = 2; */
        if (message.run)
            Run.internalBinaryWrite(message.run, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitCaptureRequest
 */
export const SubmitCaptureRequest = new SubmitCaptureRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitCaptureResponse$Type extends MessageType<SubmitCaptureResponse> {
    constructor() {
        super("baserun.v1.SubmitCaptureResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitCaptureResponse>): SubmitCaptureResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitCaptureResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitCaptureResponse): SubmitCaptureResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitCaptureResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message baserun.v1.SubmitCaptureResponse
 */
export const SubmitCaptureResponse = new SubmitCaptureResponse$Type();
/**
 * @generated ServiceType for protobuf service baserun.v1.SubmissionService
 */
export const SubmissionService = new ServiceType("baserun.v1.SubmissionService", [
    { name: "StartRun", options: {}, I: StartRunRequest, O: StartRunResponse },
    { name: "SubmitLog", options: {}, I: SubmitLogRequest, O: SubmitLogResponse },
    { name: "SubmitSpan", options: {}, I: SubmitSpanRequest, O: SubmitSpanResponse },
    { name: "EndRun", options: {}, I: EndRunRequest, O: EndRunResponse },
    { name: "SubmitEval", options: {}, I: SubmitEvalRequest, O: SubmitEvalResponse },
    { name: "StartTestSuite", options: {}, I: StartTestSuiteRequest, O: StartTestSuiteResponse },
    { name: "EndTestSuite", options: {}, I: EndTestSuiteRequest, O: EndTestSuiteResponse },
    { name: "StartSession", options: {}, I: StartSessionRequest, O: StartSessionResponse },
    { name: "EndSession", options: {}, I: EndSessionRequest, O: EndSessionResponse },
    { name: "SubmitTemplateVersion", options: {}, I: SubmitTemplateVersionRequest, O: SubmitTemplateVersionResponse },
    { name: "SubmitModelConfig", options: {}, I: SubmitModelConfigRequest, O: SubmitModelConfigResponse },
    { name: "SubmitUser", options: {}, I: SubmitUserRequest, O: SubmitUserResponse },
    { name: "GetTemplates", options: {}, I: GetTemplatesRequest, O: GetTemplatesResponse },
    { name: "SubmitCapture", options: {}, I: SubmitCaptureRequest, O: SubmitCaptureResponse }
]);
